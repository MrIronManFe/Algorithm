/*
写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

示例:
输入: a = 1, b = 1
输出: 2

提示：
a, b 均可能是负数或 0
结果不会溢出 32 位整数
*/

/*
数的运算无非就是四则运算或者位运算，既然题目不给我们用四则运算，那就只能用位运算了。我们可以用三步法来解决本题。

先用十进制来举个例子。假如我们要算 8 + 13，那么第一步我们只做每一位的相加但是不进位，那么此时相加的结果为 11（个位 8 + 3 相加不进位是 1，十位 0 + 1 相加是 1）；第二步只算进位，只有 8 + 3 中有进位，所以进位的值是 10；第三步把前面两步的结果加起来，则有：11 + 10 = 21。刚好等于 8 + 13 = 21。
那如果我们把这三步法移植到二进制上来（因为位运算是在二进制形式的数上进行的），8 的二进制是 1000，13 的二进制是 1101。那么经过第一步我们会得到：0101；第二步会得到：10000；第三步将前两步的数相加，得到：10101。刚好等于 1000 + 1101 = 10101。
明白了三步法，我们现在把二进制与位运算联系起来。我们可以观察到，第一步不算进位的加法操作，与 异或运算 的结果是一样的，在我们的例子中就是： 1000 ^ 1101 = 0101；第二步只算进位的操作，跟 位与运算再往左移一位 的结果是一样的，在我们的例子中就是：(1000 & 1101) << 1 = 10000；第三步则是将前两步相加，聪明的你肯定能想到，第三步可以 复用 第一步！因为都是加法操作！也就是说第三步可以通过 第一步的结果 ^ 第二步的结果 来实现。

作者：superkakayong
链接：https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/zi-jie-ti-ku-jian-65-jian-dan-bu-yong-ji-5k3q/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/

/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var add = function(a, b) {
    // 递归
    if (a == 0) return b;
    if (b == 0) return a;
    return add((a ^ b), ((a & b) << 1));
};

// https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/zi-jie-ti-ku-jian-65-jian-dan-bu-yong-ji-5k3q/